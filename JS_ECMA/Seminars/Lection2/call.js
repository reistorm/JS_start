// Сработало, но каждый раз оборачивать метод в анонимную функцию не очень
// удобно, есть способы лучше. Все они связаны с привязкой контекста (нужного нам
// объекта) во время вызова функции. Это уже знакомый нам метод call, а также еще
// два метода apply и bind.
    
// Метод call позволяет вызвать функцию и явно указать с каким объектом 
// контекста её выполнить (передать в качестве первого аргумента объект, 
// который будет доступен в функции через ключевое слово this). 
// Давайте посмотрим на примере с пылесосом

// Обращение к свойствам объекта.
console.log(Roomba.model); // "Romba-1"
console.log(Roomba.isFull); // false

// Вызов методов объекта.
// Вызов метода объекта через call с явной передачей объекта
//робота-пылесоса в качестве контекста.
Roomba.startCleaning.call(Roomba); // I am cleaning... I have started: 1 times.
// Тут этот пример не очень показателен, т.к. Мы и так имели
// доступ к объекту, а внутри setTimeout использовать call возможно
// только обернув все это в анонимную функцию, но тоже бессмысленно,
// потому что тогда мы снова имеем доступ к объекту, как видели в
// прошлом примере. Но мы можем передать в call другой объект и
// увидеть что функция вызывается в контексте другого объекта:


// Создадим фиктивный объект робота, который содержит только одно
// свойство, необходимое для работы функции и сразу же зададим ему
// первоначальное значение, отличное от того, которое задано у
// робота, для наглядности.
const notARobot = {
    counterOfStarts: 10,
};
Roomba.startCleaning.call(notARobot); 
// I am cleaning... I have been started: 11 times.


//////////////////////////
// Как мы видим, метод call позволил нам вызвать метод пользовательского объекта,
// но при этом указать в качестве контекста совсем другой объект и это сработало.
// Таким способом мы можем использовать метод call для вызова любой функции с
// нужным нам контекстом. Если вызываемая функция принимает аргументы, то их
// можно указать после объекта контекста, второй и все последующие аргументы
// метода call будут переданы как аргументы вызываемой функции.
// Подобно методу call можно использовать метод apply, который также позволяет
// вызвать функцию и передать необходимый контекст, единственным отличием от
// call, метод apply принимает аргументы, которые необходимо передать в
// вызываемую функцию не списком через запятую, а в виде массива, что порой
// удобнее. В нашем пример методы не принимают аргументов, но если бы
// принимали, это могло бы выглядеть вот так:

const notARobot2 = {
    counterOfStarts: 10,
    };
// Пример использования метода apply, для вызова функции с
// передачей в качестве контекста объекта notARobot и передачей в
// неё аргументов arg1, arg2, arg3. (Удобнее для массивов)
Roomba.startCleaning.apply(notARobot2, [arg1, arg2, arg3]); 
// I am cleaning... I have been started: 11 times.
    

// ////////////////

// И последний метод для привязки контекста это bind (от английского bind -
// связывать) - это самый часто используемый метод, т.к. позволяет привязать
// контекст к функции раз и навсегда, и в дальнейшем мы можем просто вызывать
// функции и быть уверены, что она будет вызвана в контексте нужного нам объекта.
// Именно он поможет нам, чтобы починить наш алгоритм тестирования робота с
// использованием setTimeout. Метод работает очень просто, его нужно вызвать для
// необходимой нам функции и передать в него единственный аргумент - объект в
// контексте которого мы хотим в дальнейшем вызывать нашу функцию, и наша
// функция будет привязана к этому контексту навсегда.

// Обращение к свойствам объекта.
console.log(Roomba.model); // "Romba-1"
console.log(Roomba.isFull); // false

// Вызов методов объекта.
// В setTimeout мы передаем не просто наш метод, а функцию,
// которая привязана к нашему объекту. Метод bind возвращает новую
// функцию, с уже привязанным контекстом, именно она вызывается по
// истечении времени.
setTimeout(Roomba.startCleaning.bind(Roomba), 1000);

// Установим свойства объекта isUVLampOn в true, чтобы
// продемонстрировать результат работы метода switchUVLamp.
Roomba.isUVLampOn = true;

// Результат вызова следующего метода зависит от значения,
// хранящегося в свойстве объекта, а также от того как этот метод
// был вызван (об этом поговорим чуть ниже).
setTimeout(Roomba.switchUVLamp.bind(Roomba), 2000);
setTimeout(Roomba.goCharge.bind(Roomba), 3000);
// I am cleaning... I have been started: 1 times.
// UV lamp is not working.
// I am going to charge...
